## Performance in Multithreaded applications
성능은 상황과 사용 목적에 따라 완전히 다르게 측정될 수 있다.

ex)
1. 고속 트레이딩 시스템
   - 성능 측정 기준: 지연 시간
     
     -> 트랜잭션이 빠를수록 애플리케이션의 성능이 더 좋은 것으로 여겨진다.
2. 머신 러닝 시스템
   - 성능 측정 기준: 처리량
     
     -> 시스템이 24시간 동안 수집하는 데이터가 많을 수록 더 나은 예측이 가능하기 때문

따라서, 측정과 개선에 중점을 두는 성능 지표는 상황에 따라 다르게 정의된다.

<br/><br/>

## Performance criteria
그럼에도 불구하고 많은 시스템에서 자주 사용되는 주요 성능 지표는 다음과 같다.
### Latency(지연 시간)
> 하나의 작업 완료 시간
- 시간 단위로 측정

<br/>

### Throughput(처리량)
> 일정 시간 동안 완료한 작업의 양
- 시간 단위당 작업으로 측정

<br/>

둘은 별개의 지표이며, 한 쪽이 개선되어도 한 쪽에는 영향이 없을 수도 있고 서로 여러 영향을 미칠 수도 있다.

<br/><br/>

## Latency
> 지연 시간 = T / N
- 싱글 스레드로 순차적으로 완료할 수 있는 하나의 작업에서의 지연 시간 = T
- 위의 작업을 나눈 여러 하위 작업의 개수 = N
  - 이때 각각의 하위 작업들은 병렬로 실행되도록 각자 다른 스레드에 스케줄링한다.

<br/>

멀티 스레드 프로그래밍에서 지연 시간을 줄이는 이론적인 방법은 지연 시간의 요소 중 N으로 지연 시간을 줄이는 것이다.

이때 N을 적절하게 설정하기 위해 고려해야 하는 것은 다음과 같다.

### 1. 원래 작업을 얼마나 많은 수의 하위 작업으로 나눌 수 있는가?

보통 컴퓨터에서의 하위 작업의 수는 컴퓨터의 코어 개수와 거의 비슷하게 설정해야 한다.
  
-> 하위 작업을 모두 병렬로 실행하면 지연 시간이 줄어들기 때문
    
하위 작업은 다른 코어에서 실행하는 경우에만 완전히 병렬로 실행할 수 있다.

같은 컴퓨터에서 다른 중요한 작업을 하고 있지 않다면, OS는 각각의 코어에 모든 작업을 스케줄링하고 하드웨어를 최대한 활용하여 최적의 성능을 제공한다.

코어 수 보다 하나의 스레드만 추가해도 생산성이 떨어져 성능이 저하되고, 지연 시간이 증가한다.

-> 다른 스레드와 CPU를 차지하기 위해 경쟁하므로 컨텍스트 스위칭 비용 발생, 캐시 성능 저하, 추가 메모리 소비 등으로 이어진다.
   
<br/>

이론적으로는 스레드의 개수를 코어 개수와 맞추면 최적의 성능을 제공받을 수 있어야 한다.

그러나 현실에서는 다음과 같은 이유로 최대 성능이 아닌 최대치에 근접한 성능 까지만 제공받을 수 있다.

1. 모든 스레드가 인터럽트 없이 하위 작업을 실행해야 최적의 성능을 낼 수 있다.
  
    -> 모든 스레드가 항상 RUNNABLE 상태여야 한다.(I/O 작업, blocking 호출 등도 없어야 한다.)

2. 시스템에서 CPU를 많이 소모하는 작업은 거의 실행되고 있지 않아야 한다.
3. 요즘 컴퓨터에서는 거의 하이퍼스레딩을 사용한다.
   - 하이퍼스레딩을 사용하면 물리적인 코어의 하드웨어 유닛 일부를 복제하여 두 스레드가 병행으로 실행되고 하드웨어 유닛 일부가 공유된다.
   
     -> 모든 스레드를 100% 병렬로 실행할 수 없다.

<br/>

### 2. 원래 작업을 분할하고 하위 작업을 스케줄링하여 그 결과를 나중에 합치는 과정에서 얼마나 많은 비용이 들 것인가?
하위 작업으로 분할하면 다음과 같은 비용이 발생한다.
- 하나의 작업을 여러 작업으로 분할하는 비용
- 스레드 생성 비용 및 스레드에 작업을 전달하고 시작하는 비용
- OS가 스레드를 실제로 스케줄링해 스레드가 실행되기까지의 시간
- 마지막 순서의 스레드가 작업을 완료하고 신호를 보내기까지의 시간
- 위의 신호를 받아 결과 통합 스레드가 실행되기까지의 시간
- 분할된 모든 스레드의 결과를 집계하기까지의 시간

따라서, 싱글 스레드로 모든 작업을 처리할 때만큼은 아니지만 멀티 스레드로 작업을 처리해도 지연 시간은 증가한다.


<br/>

### 3. 어떤 작업이든 원하는 만큼의 하위 작업으로 나눌 수 있는가?
모든 작업을 병행으로 실행할 수 있는 것은 아니다.

작업은 크게 세 가지 유형으로 나눌 수 있는데
- 본질적으로 병행 가능하며 하위 작업으로 쉽게 분할되는 작업
- 분할이 불가능해 처음부터 끝까지 싱글 스레드를 쓸 수 밖에 없는 작업
- 부분적으로 하위 작업으로 분할할 수 있는 작업

이 중 첫 번째와 세 번째 유형의 작업만 멀티스레딩으로 실행이 가능하다.

<br/>

### 이미지 프로세싱 예시
이미지 프로세싱 예시에서 알 수 있듯이, 물리적인 코어 수 만큼 스레드를 늘리면 이미지 프로세싱 작업의 지연 시간이 줄어든 것을 알 수 있다.

하지만 물리적인 코어 수를 넘어 가상 코어 수 만큼까지 스레드를 늘리다보면 오히려 역효과를 낳을 수 있다.

-> 스레드끼리 서로 리소스를 공유하기 때문(하이퍼스레딩)

<br/>

또한, 동일한 수의 스레드로 병렬 처리를 한다고 했을 때 원본 이미지의 성능 향상률은 약 70% 였다.

하지만 저해상도의 이미지일수록 병렬 처리로 얻을 수 있는 성능 향상은 미미하고, 오히려 성능 처하를 일으킬 수 있다.

-> 스레드가 처리할 이미지 픽셀 수가 적어져서 병렬 작업으로 인한 비용이 더 커졌기 때문 